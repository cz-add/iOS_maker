# OC对象的内存管理

在iOS中，使用引用计数来管理OC对象的内存。

一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间。

调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1。

* * *

# 内存管理经验总结

当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它。

想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1。

# 引用计数的存储

引用计数存在优化过的isa共用体的extra_rc中，当数字过大，共用体分配的extra_rc的内存不够用了，共用体的has_sidetable_rc就会变为1，然后引用计数就会存储在SideTable中的refcnts散列表中。

* * *

# 内存布局

内存地址从低到高，一共分为代码段，数据段，堆，栈。

代码段： 存放编译之后的代码。

数据段： 1.字符串常量:比如 Nsstring *str=@"123" 2.已初始化数据:已初始化的全局变量、静态变量等。 3.未初始化数据:末初始化的全局变量、静态变量等。

堆： 通过alloc、 malloc、 calloc等动态分配的空间。 分配的内存空间地址越来越大。

栈： 函数调用开销,比如局部变量。 分配的内存空间地址越来越小。

# 深拷贝、浅拷贝、copy、mutableCopy

深拷贝： 内容拷贝，产生新的对象。

浅拷贝： 指针拷贝，没有产生新的对象。

copy: 不可变拷贝，产生不可变副本。

mutableCopy: 可变拷贝，产生可变副本。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0601/151749_3070babc_9027123.png "gz.png")

结论：

1.对字符串，字典，数组进行mutableCopy操作，属于深拷贝，并且会生成一个新的可变对象。

2.对可变字符串，字典，数组进行copy操作，属于深拷贝，并且会生成一个新的不可变对象。

3.对不可变字符串，字典，数组进行copy操作，属于浅拷贝，不会生成一个新的对象。

* * *

# 补充

1.refcnts是一个存放着对象引用计数的散列表。
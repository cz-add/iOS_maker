## 卡顿优化
----
添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的

#### CPU：

1.  使用轻量级的对象比如用不到事件处理的地方，可以考虑使用CALayer取代UIView
2.  不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
3.  尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
4.  Autolayout会比直接设置frame消耗更多的CPU资源
5.  图片的size最好刚好跟UIImageView的size保持一致
6.  控制一下线程的最大并发数量
7.  尽量把耗时的操作放到子线程，如文字尺寸计算、绘制，图片解码、绘制、压缩

#### GPU：

1.  尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
2.  GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
3.  尽量减少视图数量和层次
4.  减少透明的视图（alpha<1），不透明的就设置opaque为YES
5.  尽量避免出现离屏渲染(离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作)

*   会触发离屏渲染的操作：

1.  光栅化，layer.shouldRasterize = YES
2.  遮   罩，layer.mask
3.  圆   角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0
4.  阴   影，layer.shadowXXX

## 耗电优化
----
1.  少用定时器
2.  尽量不要频繁写入小数据，最好批量一次性写入
3.  读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问
4.  数据量比较大的，建议使用数据库（比如SQLite、CoreData）
5.  减少、压缩网络数据
6.  如果多次请求的结果是相同的，尽量使用缓存
7.  使用断点续传，否则网络不稳定时可能多次传输相同的内容
8.  网络不可用时，不要尝试执行网络请求
9.  让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间
10.  批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载
11.  如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电
12.  如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务
13.  尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest
14.  需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新
15.  尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion:
16.  用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件

## 启动速度优化
----
1.  减少动态库、合并一些动态库（定期清理不必要的动态库）
2.  减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）
3.  减少C++虚函数数量
4.  Swift尽量使用struct
5.  用+initialize方法和dispatch_once取代所有的**attribute**((constructor))、C++静态构造器、ObjC的+load
6.  在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中
7.  按需加载

## 包大小优化
----
1.  资源（图片、音频、视频等）采取无损压缩
2.  编写LLVM插件检测出重复代码、未被调用的代码
